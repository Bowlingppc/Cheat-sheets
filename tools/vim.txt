##############################################################################
# VIM CHEATSHEET
# WEBSITE: http://www.vim.org/  
# DOCUMENTATION: https://vim.sourceforge.io/docs.php
# CTRL-A = <C-a>
##############################################################################


##############################################################################
# INSERT MODE
##############################################################################


i                   start insert mode at cursor
I                   insert at the beginning of the line
a                   append after the cursor
A                   append at the end of the line
o                   open (append) blank line below current line
O                   open blank line above current line
<Esc>               exit insert mode


##############################################################################
# EXITING
##############################################################################


:q                  quit Vim, fails when changes have been made
:q!                 quit without writing
:cq                 quit always, without writing
:w                  save without exiting
:wq                 write the current file and exit
:wq!                write the current file and exit always
:wq {file}          write to {file} Exit if not editing the last
:wq! {file}         write to {file} and exit always
:[range]wq[!]       same as above, but only write the lines in [range]
ZZ                  write current file, if modified, and exit
ZQ                  quit current file and exit (same as ":q!")


##############################################################################
# CURSOR MOVEMENTS
##############################################################################


h                   move a character left
j                   move a line down
k                   move a line up
l                   move a character right
gj                  move a visual line down
gk                  move a visual line up
w                   jump by start of words (punctuation considered words)
W                   jump by words (spaces separate words)
e                   jump to end of words (punctuation considered words)
E                   jump to end of words (no punctuation)
b                   jump backward by words (punctuation considered words)
B                   jump backward by words (no punctuation)
ge                  jump backward to end of words
0                   (zero) start of line
^                   first non-whitespace character of line
$                   end of line
n$                  move to the end of line n lines down
-                   move line upwards, on the first non-whitespace character
+                   move line downwards, on the first non-whitespace character
<enter>             move line downwards, on the first non-whitespace character
gg                  go to first line
G                   go to last line
ngg                 go to line n
nG                  go to line n
:n                  go to line n
:-n                 go n lines up, like nk
:+n                 go n lines down, like nj
)                   move the cursor forward to the next sentence
(                   move the cursor backward by a sentence
{                   move the cursor a paragraph backwards
}                   move the cursor a paragraph forwards
]]                  move the cursor a section forwards or to the next {
[[                  move the cursor a section backwards or the previous {
<C-f>               move the cursor forward by a screen of text
<C-b>               move the cursor backward by a screen of text
<C-u>               move the cursor up by half a screen
<C-d>               move the cursor down by half a screen
H                   move the cursor to the top of the screen
M                   move the cursor to the middle of the screen
L                   move the cursor to the bottom of the screen
fx                  find and move on next occurance of x on current line
Fx                  find and move on previous occurance of x on current line
tx                  find and move to next occurance of x on current line
Tx                  find and move to previous occurance of x on current line
;                   rerun last f/F/t/T movement
,                   rerun last f/F/t/T movement but in the opposite way
%                   show matching brace, bracket, or parenthese


##############################################################################
# EDITING
##############################################################################


r                   replace a single character (does not use insert mode)
R                   enter Insert mode, replacing characters rather than inserting
J                   join line below to the current one and add space
gJ                  join line below to the current one without adding space
cc                  change an entire line
cw                  change to the end of word
ciw                 change whole word regardless of where you are in it
cip                 change in paragaph (between new lines)
cap                 change around paragaph and the paragraph itself
ci(                 change in pair of (, works with { [ " ' ` < too
ca(                 change in and around pair of (, works with { [ " ' ` < too
C                   change to the end of line
ct'                 change until the ' character (can change ' for any character)
ci"                 change everything in the next " on the line
s                   delete character at cursor and substitute text
S                   delete line at cursor and substitute text (same as cc)
xp                  transpose two letters (delete and paste, technically)
u                   undo
<C-r>               redo
<C-a>               increment number under cursor
<C-x>               decrement number under cursor
.                   repeat last command
~                   switch case
g~iw                switch case of current word
gUiw                make current word uppercase
guiw                make current word lowercase
gU$                 make uppercase until end of line
gu$                 make lowercase until end of line
>>                  indent line one column to right
<<                  indent line one column to left
<ip                 indent in paragraph to the left
>ip                 outdent in paragraph to the left
<ap                 indent around paragraph to the left and the paragraph itself
>ap                 outdent around paragraph to the left and the paragraph itself
==                  auto-indent current line
ddp                 swap current line with next
ddkp                swap current line with previous
g??                 rot13 encode current line, useful for spoilering text
<C-r>=3+3           in insert mode, will evaluate 3+3 and paste it, works with simple expressions


##############################################################################
# DELETING TEXT
##############################################################################


x                   delete current character
X                   delete previous character
dw                  delete the current word
dd                  delete (cut) a line
diw                 delete whole word regardless of where you are in it
dip                 delte in paragraph
dap                 delte around paragraph and the paragraph itself
dt'                 delete until the next ' character on the line (replace ' by any character)
D                   delete from cursor to end of line
:[range]d           delete [range] lines
di(                 delete in pair of (, works with { [ " ' too
da(                 delete in and around pair of (, works with { [ " ' too

##############################################################################
# COPYING AND MOVING TEXT
##############################################################################


yw                  yank word
yy                  yank (copy) a line
nyy                 yank n lines
y$                  yank to end of line
yiw                 yank whole word regardless of where you are in it
yip                 yank in paragaph (between new lines)
yap                 yank around paragaph and the paragraph itself
yi(                 yank in pair of (, works with { [ " ' too
ya(                 yank in and around pair of (, works with { [ " ' too
p                   put (paste) the clipboard after cursor/current line
P                   put (paste) before cursor/current line
:set paste          avoid unexpected effects in pasting
:registers          display the contents of all registers
"xyw                yank word into register x
"xyy                yank line into register x
:[range]y x         yank [range] lines into register x
"xp                 put the text from register x after the cursor
"xP                 put the text from register x before the cursor
"xgp                just like "p", but leave the cursor just after the new text
"xgP                just like "P", but leave the cursor just after the new text
:[line]put x        put the text from register x after [line]


##############################################################################
# MACROS
##############################################################################


qa                  start recording macro to register a
q                   end recording macro
@a                  replay macro 'a'
@@                  replay last macro
@:                  replay last command
"ap                 paste the conents of the a register/macro
"ayy                yank the current line into the a register/macro

##############################################################################
# VISUAL MODE
##############################################################################


v                   start visual mode, mark lines, then do command (such as y-yank)
V                   start linewise visual mode
o                   move to other end of marked area
U                   upper case of marked area
<C-v>               start visual block mode
O                   move to other corner of block
aw                  mark a word
ab                  a () block (with braces)
ab                  a {} block (with brackets)
ib                  inner () block
ib                  inner {} block
vap                 visually select paragraph and around it
vip                 visually select in paragraph
v%                  matching parenthesis
vi{                 selects matching curly brace
vi"                 selects text between double quotes
vi'                 selects text between single quotes
va"                 selects text around double quotes
va'                 selects text around single quotes
g<C-a>              increment selected text but increment with one more each time
g<C-x>              decrement selected text but decrement with one more each time

##############################################################################
# SPELLING
##############################################################################


]s                  next misspelled word
[s                  previous misspelled word
zg                  add word to wordlist
zug                 undo last add word
z=                  suggest word


##############################################################################
# SEARCH/REPLACE
##############################################################################


/pattern                    search for pattern
?pattern                    search backward for pattern
n                           repeat search in same direction
N                           repeat search in opposite direction
*                           search forward, word under cursor
#                           search backward, word under cursor
set ignorecase              ignore case: turn on
set noignorecase            ignore case: turn off
:%s/old/new/g               replace all old with new throughout file
:%s/old/new/gc              replace all old with new throughout file with confirmation
:argdo %s/old/new/gc | wq   open multiple files and run this command to replace old 
                            with new in every file with confirmation, save and quit


##############################################################################
# BOOKMARKS
##############################################################################


:marks              list all the current marks
ma                  make a bookmark named a at the current cursor position
`a                  go to position of bookmark a
'a                  go to the line with bookmark a
`.                  go to the line that you last edited


##############################################################################
# MULTIPLE FILES AND BUFFERS
##############################################################################


:e filename         edit a file in a new buffer
:tabe filename      edit a file in a new tab (Vim7, gVim)
:ls                 list all buffers
:bn                 go to next buffer
:bp                 go to previous buffer
:bd                 delete a buffer (close a file)
:b1                 show buffer 1
:b vimrc            show buffer whose filename begins with "vimrc"
:bufdo <command>    run 'command(s)' in all buffers
:[range]bufdo <command> run 'command(s)' for buffers in 'range'


##############################################################################
# WINDOWS
##############################################################################


:sp file            horizontal split open file, if you don't specify it opens the current one
:vsp file           vertical split open file, if you don't specify it opens the current one
<C-ws>              split windows
<C-ww>              switch between windows
<C-wq>              quit a window
<C-wv>              split windows vertically
<C-wx>              swap windows
<C-wh>              left window
<C-wj>              down window
<C-wk>              up window
<C-wl>              right window
<C-w+>              increase window height
<C-w->              decrease window height
<C-w<>              increase window width
<C-w>>              decrease window width
<C-w=>              equal window
<C-wo>              close other windows
zz                  visually puts current line at the center of the screen


##############################################################################
# QUICKFIX WINDOW
##############################################################################


copen               open quickfix window
cclose              close quickfix window
cc [nr]             display error [nr]
cfirst              display the first error
clast               display the last error
[count]cn           display [count] next error
[count]cp           display [count] previous error


##############################################################################
# PROGRAMMING
##############################################################################


gf                  edit the file whose name is under or after the cursor
gd                  if cursor is on a local variable or function, jump to its declaration
''                  return to the line where the cursor was before the latest jump
gi                  return to insert mode where you inserted text the last time
<C-o>               move to previous position you were at
<C-i>               move to more recent position you were at


##############################################################################
# COMMANDS
##############################################################################


q:                  list command history
:set optionName     set the optionName option
:h[elp] command     open offline help menu for command
:put                paste
:put = 3+3          calculate 3+3 and put it on a new line, works with basic expressions
:%retab             fix spaces / tabs issues in whole file
:r [name]           insert the file [name] below the cursor
:r !{cmd}           execute {cmd} and insert its standard output below the cursor
:%le                remove all leading whitespace
:%y                 yank whole file
:[range]norm Ihi    run a sequence of commands on a range of lines
